#![allow(clippy::enum_variant_names)]

// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Configuration {
	/// JSON string containing configuration data expected by the plugin,
	/// pulled from the user's policy file.
	#[prost(string, tag = "1")]
	pub configuration: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigurationResult {
	/// The status of the configuration call.
	#[prost(enumeration = "ConfigurationStatus", tag = "1")]
	pub status: i32,
	/// An optional error message, if there was an error.
	#[prost(string, tag = "2")]
	pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyExpression {
	/// A policy expression, if the plugin has a default policy.
	/// This MUST be filled in with any default values pulled from the plugin's
	/// configuration. Hipcheck will only request the default policy _after_
	/// configuring the plugin.
	#[prost(string, tag = "1")]
	pub policy_expression: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
	/// The name of the query being described by the schemas provided.
	///
	/// If either the key and/or output schemas result in a message which is
	/// too big, they may be chunked across multiple replies in the stream.
	/// Replies with matching query names should have their fields concatenated
	/// in the order received to reconstruct the chunks.
	#[prost(string, tag = "1")]
	pub query_name: ::prost::alloc::string::String,
	/// The key schema, in JSON Schema format.
	#[prost(string, tag = "2")]
	pub key_schema: ::prost::alloc::string::String,
	/// The output schema, in JSON Schema format.
	#[prost(string, tag = "3")]
	pub output_schema: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Query {
	/// The ID of the request, used to associate requests and replies.
	/// Odd numbers = initiated by `hc`.
	/// Even numbers = initiated by a plugin.
	#[prost(int32, tag = "1")]
	pub id: i32,
	/// The state of the query, indicating if this is a request or a reply,
	/// and if it's a reply whether it's the end of the reply.
	#[prost(enumeration = "QueryState", tag = "2")]
	pub state: i32,
	/// Publisher name and plugin name, when sent from Hipcheck to a plugin
	/// to initiate a fresh query, are used by the receiving plugin to validate
	/// that the query was intended for them.
	///
	/// When a plugin is making a query to another plugin through Hipcheck, it's
	/// used to indicate the destination plugin, and to indicate the plugin that
	/// is replying when Hipcheck sends back the reply.
	#[prost(string, tag = "3")]
	pub publisher_name: ::prost::alloc::string::String,
	#[prost(string, tag = "4")]
	pub plugin_name: ::prost::alloc::string::String,
	/// The name of the query being made, so the responding plugin knows what
	/// to do with the provided data.
	#[prost(string, tag = "5")]
	pub query_name: ::prost::alloc::string::String,
	/// The key for the query, as a JSON object. This is the data that Hipcheck's
	/// incremental computation system will use to cache the response.
	#[prost(string, tag = "6")]
	pub key: ::prost::alloc::string::String,
	/// The response for the query, as a JSON object. This will be cached by
	/// Hipcheck for future queries matching the publisher name, plugin name,
	/// query name, and key.
	#[prost(string, tag = "7")]
	pub output: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Empty {}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConfigurationStatus {
	/// An unknown error occured.
	ErrorUnknown = 0,
	/// No error; the operation was successful.
	ErrorNone = 1,
	/// The user failed to provide a required configuration item.
	ErrorMissingRequiredConfiguration = 2,
	/// The user provided a configuration item whose name was not recognized.
	ErrorUnrecognizedConfiguration = 3,
	/// The user provided a configuration item whose value is invalid.
	ErrorInvalidConfigurationValue = 4,
}
impl ConfigurationStatus {
	/// String value of the enum field names used in the ProtoBuf definition.
	///
	/// The values are not transformed in any way and thus are considered stable
	/// (if the ProtoBuf definition does not change) and safe for programmatic use.
	pub fn as_str_name(&self) -> &'static str {
		match self {
			ConfigurationStatus::ErrorUnknown => "ERROR_UNKNOWN",
			ConfigurationStatus::ErrorNone => "ERROR_NONE",
			ConfigurationStatus::ErrorMissingRequiredConfiguration => {
				"ERROR_MISSING_REQUIRED_CONFIGURATION"
			}
			ConfigurationStatus::ErrorUnrecognizedConfiguration => {
				"ERROR_UNRECOGNIZED_CONFIGURATION"
			}
			ConfigurationStatus::ErrorInvalidConfigurationValue => {
				"ERROR_INVALID_CONFIGURATION_VALUE"
			}
		}
	}
	/// Creates an enum from field names used in the ProtoBuf definition.
	pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
		match value {
			"ERROR_UNKNOWN" => Some(Self::ErrorUnknown),
			"ERROR_NONE" => Some(Self::ErrorNone),
			"ERROR_MISSING_REQUIRED_CONFIGURATION" => Some(Self::ErrorMissingRequiredConfiguration),
			"ERROR_UNRECOGNIZED_CONFIGURATION" => Some(Self::ErrorUnrecognizedConfiguration),
			"ERROR_INVALID_CONFIGURATION_VALUE" => Some(Self::ErrorInvalidConfigurationValue),
			_ => None,
		}
	}
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueryState {
	/// Something has gone wrong.
	QueryUnspecified = 0,
	/// We are submitting a new query.
	QuerySubmit = 1,
	/// We are replying to a query and expect more chunks.
	QueryReplyInProgress = 2,
	/// We are closing a reply to a query. If a query response is in one chunk,
	/// just send this. If a query is in more than one chunk, send this with
	/// the last message in the reply. This tells the receiver that all chunks
	/// have been received.
	QueryReplyComplete = 3,
}
impl QueryState {
	/// String value of the enum field names used in the ProtoBuf definition.
	///
	/// The values are not transformed in any way and thus are considered stable
	/// (if the ProtoBuf definition does not change) and safe for programmatic use.
	pub fn as_str_name(&self) -> &'static str {
		match self {
			QueryState::QueryUnspecified => "QUERY_UNSPECIFIED",
			QueryState::QuerySubmit => "QUERY_SUBMIT",
			QueryState::QueryReplyInProgress => "QUERY_REPLY_IN_PROGRESS",
			QueryState::QueryReplyComplete => "QUERY_REPLY_COMPLETE",
		}
	}
	/// Creates an enum from field names used in the ProtoBuf definition.
	pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
		match value {
			"QUERY_UNSPECIFIED" => Some(Self::QueryUnspecified),
			"QUERY_SUBMIT" => Some(Self::QuerySubmit),
			"QUERY_REPLY_IN_PROGRESS" => Some(Self::QueryReplyInProgress),
			"QUERY_REPLY_COMPLETE" => Some(Self::QueryReplyComplete),
			_ => None,
		}
	}
}
/// Generated client implementations.
pub mod plugin_client {
	#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
	use tonic::codegen::http::Uri;
	use tonic::codegen::*;
	#[derive(Debug, Clone)]
	pub struct PluginClient<T> {
		inner: tonic::client::Grpc<T>,
	}
	impl PluginClient<tonic::transport::Channel> {
		/// Attempt to create a new client by connecting to a given endpoint.
		pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
		where
			D: TryInto<tonic::transport::Endpoint>,
			D::Error: Into<StdError>,
		{
			let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
			Ok(Self::new(conn))
		}
	}
	impl<T> PluginClient<T>
	where
		T: tonic::client::GrpcService<tonic::body::BoxBody>,
		T::Error: Into<StdError>,
		T::ResponseBody: Body<Data = Bytes> + Send + 'static,
		<T::ResponseBody as Body>::Error: Into<StdError> + Send,
	{
		pub fn new(inner: T) -> Self {
			let inner = tonic::client::Grpc::new(inner);
			Self { inner }
		}
		pub fn with_origin(inner: T, origin: Uri) -> Self {
			let inner = tonic::client::Grpc::with_origin(inner, origin);
			Self { inner }
		}
		pub fn with_interceptor<F>(
			inner: T,
			interceptor: F,
		) -> PluginClient<InterceptedService<T, F>>
		where
			F: tonic::service::Interceptor,
			T::ResponseBody: Default,
			T: tonic::codegen::Service<
				http::Request<tonic::body::BoxBody>,
				Response = http::Response<
					<T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
				>,
			>,
			<T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
				Into<StdError> + Send + Sync,
		{
			PluginClient::new(InterceptedService::new(inner, interceptor))
		}
		/// Compress requests with the given encoding.
		///
		/// This requires the server to support it otherwise it might respond with an
		/// error.
		#[must_use]
		pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
			self.inner = self.inner.send_compressed(encoding);
			self
		}
		/// Enable decompressing responses.
		#[must_use]
		pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
			self.inner = self.inner.accept_compressed(encoding);
			self
		}
		/// Limits the maximum size of a decoded message.
		///
		/// Default: `4MB`
		#[must_use]
		pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
			self.inner = self.inner.max_decoding_message_size(limit);
			self
		}
		/// Limits the maximum size of an encoded message.
		///
		/// Default: `usize::MAX`
		#[must_use]
		pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
			self.inner = self.inner.max_encoding_message_size(limit);
			self
		}
		/// *
		/// Get schemas for all supported queries by the plugin.
		///
		/// This is used by Hipcheck to validate that:
		///
		/// - The plugin supports a default query taking a `target` type if used
		///   as a top-level plugin in the user's policy file.
		/// - That requests sent to the plugin and data returned by the plugin
		///   match the schema during execution.
		pub async fn get_query_schemas(
			&mut self,
			request: impl tonic::IntoRequest<super::Empty>,
		) -> std::result::Result<
			tonic::Response<tonic::codec::Streaming<super::Schema>>,
			tonic::Status,
		> {
			self.inner.ready().await.map_err(|e| {
				tonic::Status::new(
					tonic::Code::Unknown,
					format!("Service was not ready: {}", e.into()),
				)
			})?;
			let codec = tonic::codec::ProstCodec::default();
			let path = http::uri::PathAndQuery::from_static("/hipcheck.Plugin/GetQuerySchemas");
			let mut req = request.into_request();
			req.extensions_mut()
				.insert(GrpcMethod::new("hipcheck.Plugin", "GetQuerySchemas"));
			self.inner.server_streaming(req, path, codec).await
		}
		/// *
		/// Hipcheck sends all child nodes for the plugin from the user's policy
		/// file to configure the plugin.
		pub async fn set_configuration(
			&mut self,
			request: impl tonic::IntoRequest<super::Configuration>,
		) -> std::result::Result<tonic::Response<super::ConfigurationResult>, tonic::Status> {
			self.inner.ready().await.map_err(|e| {
				tonic::Status::new(
					tonic::Code::Unknown,
					format!("Service was not ready: {}", e.into()),
				)
			})?;
			let codec = tonic::codec::ProstCodec::default();
			let path = http::uri::PathAndQuery::from_static("/hipcheck.Plugin/SetConfiguration");
			let mut req = request.into_request();
			req.extensions_mut()
				.insert(GrpcMethod::new("hipcheck.Plugin", "SetConfiguration"));
			self.inner.unary(req, path, codec).await
		}
		/// *
		/// Get the default policy for a plugin, which may additionally depend on
		/// the plugin's configuration.
		pub async fn get_default_policy_expression(
			&mut self,
			request: impl tonic::IntoRequest<super::Empty>,
		) -> std::result::Result<tonic::Response<super::PolicyExpression>, tonic::Status> {
			self.inner.ready().await.map_err(|e| {
				tonic::Status::new(
					tonic::Code::Unknown,
					format!("Service was not ready: {}", e.into()),
				)
			})?;
			let codec = tonic::codec::ProstCodec::default();
			let path =
				http::uri::PathAndQuery::from_static("/hipcheck.Plugin/GetDefaultPolicyExpression");
			let mut req = request.into_request();
			req.extensions_mut().insert(GrpcMethod::new(
				"hipcheck.Plugin",
				"GetDefaultPolicyExpression",
			));
			self.inner.unary(req, path, codec).await
		}
		/// *
		/// Open a bidirectional streaming RPC to enable a request/response
		/// protocol between Hipcheck and a plugin, where Hipcheck can issue
		/// queries to the plugin, and the plugin may issue queries to _other_
		/// plugins through Hipcheck.
		///
		/// Queries are cached by the publisher name, plugin name, query name,
		/// and key, and if a match is found for those four values, then
		/// Hipcheck will respond with the cached result of that prior matching
		/// query rather than running the query again.
		pub async fn initiate_query_protocol(
			&mut self,
			request: impl tonic::IntoStreamingRequest<Message = super::Query>,
		) -> std::result::Result<
			tonic::Response<tonic::codec::Streaming<super::Query>>,
			tonic::Status,
		> {
			self.inner.ready().await.map_err(|e| {
				tonic::Status::new(
					tonic::Code::Unknown,
					format!("Service was not ready: {}", e.into()),
				)
			})?;
			let codec = tonic::codec::ProstCodec::default();
			let path =
				http::uri::PathAndQuery::from_static("/hipcheck.Plugin/InitiateQueryProtocol");
			let mut req = request.into_streaming_request();
			req.extensions_mut()
				.insert(GrpcMethod::new("hipcheck.Plugin", "InitiateQueryProtocol"));
			self.inner.streaming(req, path, codec).await
		}
	}
}
/// Generated server implementations.
pub mod plugin_server {
	#![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
	use tonic::codegen::*;
	/// Generated trait containing gRPC methods that should be implemented for use with PluginServer.
	#[async_trait]
	pub trait Plugin: Send + Sync + 'static {
		/// Server streaming response type for the GetQuerySchemas method.
		type GetQuerySchemasStream: tonic::codegen::tokio_stream::Stream<
				Item = std::result::Result<super::Schema, tonic::Status>,
			> + Send
			+ 'static;
		/// *
		/// Get schemas for all supported queries by the plugin.
		///
		/// This is used by Hipcheck to validate that:
		///
		/// - The plugin supports a default query taking a `target` type if used
		///   as a top-level plugin in the user's policy file.
		/// - That requests sent to the plugin and data returned by the plugin
		///   match the schema during execution.
		async fn get_query_schemas(
			&self,
			request: tonic::Request<super::Empty>,
		) -> std::result::Result<tonic::Response<Self::GetQuerySchemasStream>, tonic::Status>;
		/// *
		/// Hipcheck sends all child nodes for the plugin from the user's policy
		/// file to configure the plugin.
		async fn set_configuration(
			&self,
			request: tonic::Request<super::Configuration>,
		) -> std::result::Result<tonic::Response<super::ConfigurationResult>, tonic::Status>;
		/// *
		/// Get the default policy for a plugin, which may additionally depend on
		/// the plugin's configuration.
		async fn get_default_policy_expression(
			&self,
			request: tonic::Request<super::Empty>,
		) -> std::result::Result<tonic::Response<super::PolicyExpression>, tonic::Status>;
		/// Server streaming response type for the InitiateQueryProtocol method.
		type InitiateQueryProtocolStream: tonic::codegen::tokio_stream::Stream<
				Item = std::result::Result<super::Query, tonic::Status>,
			> + Send
			+ 'static;
		/// *
		/// Open a bidirectional streaming RPC to enable a request/response
		/// protocol between Hipcheck and a plugin, where Hipcheck can issue
		/// queries to the plugin, and the plugin may issue queries to _other_
		/// plugins through Hipcheck.
		///
		/// Queries are cached by the publisher name, plugin name, query name,
		/// and key, and if a match is found for those four values, then
		/// Hipcheck will respond with the cached result of that prior matching
		/// query rather than running the query again.
		async fn initiate_query_protocol(
			&self,
			request: tonic::Request<tonic::Streaming<super::Query>>,
		) -> std::result::Result<tonic::Response<Self::InitiateQueryProtocolStream>, tonic::Status>;
	}
	#[derive(Debug)]
	pub struct PluginServer<T: Plugin> {
		inner: Arc<T>,
		accept_compression_encodings: EnabledCompressionEncodings,
		send_compression_encodings: EnabledCompressionEncodings,
		max_decoding_message_size: Option<usize>,
		max_encoding_message_size: Option<usize>,
	}
	impl<T: Plugin> PluginServer<T> {
		pub fn new(inner: T) -> Self {
			Self::from_arc(Arc::new(inner))
		}
		pub fn from_arc(inner: Arc<T>) -> Self {
			Self {
				inner,
				accept_compression_encodings: Default::default(),
				send_compression_encodings: Default::default(),
				max_decoding_message_size: None,
				max_encoding_message_size: None,
			}
		}
		pub fn with_interceptor<F>(inner: T, interceptor: F) -> InterceptedService<Self, F>
		where
			F: tonic::service::Interceptor,
		{
			InterceptedService::new(Self::new(inner), interceptor)
		}
		/// Enable decompressing requests with the given encoding.
		#[must_use]
		pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
			self.accept_compression_encodings.enable(encoding);
			self
		}
		/// Compress responses with the given encoding, if the client supports it.
		#[must_use]
		pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
			self.send_compression_encodings.enable(encoding);
			self
		}
		/// Limits the maximum size of a decoded message.
		///
		/// Default: `4MB`
		#[must_use]
		pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
			self.max_decoding_message_size = Some(limit);
			self
		}
		/// Limits the maximum size of an encoded message.
		///
		/// Default: `usize::MAX`
		#[must_use]
		pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
			self.max_encoding_message_size = Some(limit);
			self
		}
	}
	impl<T, B> tonic::codegen::Service<http::Request<B>> for PluginServer<T>
	where
		T: Plugin,
		B: Body + Send + 'static,
		B::Error: Into<StdError> + Send + 'static,
	{
		type Response = http::Response<tonic::body::BoxBody>;
		type Error = std::convert::Infallible;
		type Future = BoxFuture<Self::Response, Self::Error>;
		fn poll_ready(
			&mut self,
			_cx: &mut Context<'_>,
		) -> Poll<std::result::Result<(), Self::Error>> {
			Poll::Ready(Ok(()))
		}
		fn call(&mut self, req: http::Request<B>) -> Self::Future {
			match req.uri().path() {
				"/hipcheck.Plugin/GetQuerySchemas" => {
					#[allow(non_camel_case_types)]
					struct GetQuerySchemasSvc<T: Plugin>(pub Arc<T>);
					impl<T: Plugin> tonic::server::ServerStreamingService<super::Empty> for GetQuerySchemasSvc<T> {
						type Response = super::Schema;
						type ResponseStream = T::GetQuerySchemasStream;
						type Future =
							BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
						fn call(&mut self, request: tonic::Request<super::Empty>) -> Self::Future {
							let inner = Arc::clone(&self.0);
							let fut = async move {
								<T as Plugin>::get_query_schemas(&inner, request).await
							};
							Box::pin(fut)
						}
					}
					let accept_compression_encodings = self.accept_compression_encodings;
					let send_compression_encodings = self.send_compression_encodings;
					let max_decoding_message_size = self.max_decoding_message_size;
					let max_encoding_message_size = self.max_encoding_message_size;
					let inner = self.inner.clone();
					let fut = async move {
						let method = GetQuerySchemasSvc(inner);
						let codec = tonic::codec::ProstCodec::default();
						let mut grpc = tonic::server::Grpc::new(codec)
							.apply_compression_config(
								accept_compression_encodings,
								send_compression_encodings,
							)
							.apply_max_message_size_config(
								max_decoding_message_size,
								max_encoding_message_size,
							);
						let res = grpc.server_streaming(method, req).await;
						Ok(res)
					};
					Box::pin(fut)
				}
				"/hipcheck.Plugin/SetConfiguration" => {
					#[allow(non_camel_case_types)]
					struct SetConfigurationSvc<T: Plugin>(pub Arc<T>);
					impl<T: Plugin> tonic::server::UnaryService<super::Configuration> for SetConfigurationSvc<T> {
						type Response = super::ConfigurationResult;
						type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
						fn call(
							&mut self,
							request: tonic::Request<super::Configuration>,
						) -> Self::Future {
							let inner = Arc::clone(&self.0);
							let fut = async move {
								<T as Plugin>::set_configuration(&inner, request).await
							};
							Box::pin(fut)
						}
					}
					let accept_compression_encodings = self.accept_compression_encodings;
					let send_compression_encodings = self.send_compression_encodings;
					let max_decoding_message_size = self.max_decoding_message_size;
					let max_encoding_message_size = self.max_encoding_message_size;
					let inner = self.inner.clone();
					let fut = async move {
						let method = SetConfigurationSvc(inner);
						let codec = tonic::codec::ProstCodec::default();
						let mut grpc = tonic::server::Grpc::new(codec)
							.apply_compression_config(
								accept_compression_encodings,
								send_compression_encodings,
							)
							.apply_max_message_size_config(
								max_decoding_message_size,
								max_encoding_message_size,
							);
						let res = grpc.unary(method, req).await;
						Ok(res)
					};
					Box::pin(fut)
				}
				"/hipcheck.Plugin/GetDefaultPolicyExpression" => {
					#[allow(non_camel_case_types)]
					struct GetDefaultPolicyExpressionSvc<T: Plugin>(pub Arc<T>);
					impl<T: Plugin> tonic::server::UnaryService<super::Empty> for GetDefaultPolicyExpressionSvc<T> {
						type Response = super::PolicyExpression;
						type Future = BoxFuture<tonic::Response<Self::Response>, tonic::Status>;
						fn call(&mut self, request: tonic::Request<super::Empty>) -> Self::Future {
							let inner = Arc::clone(&self.0);
							let fut = async move {
								<T as Plugin>::get_default_policy_expression(&inner, request).await
							};
							Box::pin(fut)
						}
					}
					let accept_compression_encodings = self.accept_compression_encodings;
					let send_compression_encodings = self.send_compression_encodings;
					let max_decoding_message_size = self.max_decoding_message_size;
					let max_encoding_message_size = self.max_encoding_message_size;
					let inner = self.inner.clone();
					let fut = async move {
						let method = GetDefaultPolicyExpressionSvc(inner);
						let codec = tonic::codec::ProstCodec::default();
						let mut grpc = tonic::server::Grpc::new(codec)
							.apply_compression_config(
								accept_compression_encodings,
								send_compression_encodings,
							)
							.apply_max_message_size_config(
								max_decoding_message_size,
								max_encoding_message_size,
							);
						let res = grpc.unary(method, req).await;
						Ok(res)
					};
					Box::pin(fut)
				}
				"/hipcheck.Plugin/InitiateQueryProtocol" => {
					#[allow(non_camel_case_types)]
					struct InitiateQueryProtocolSvc<T: Plugin>(pub Arc<T>);
					impl<T: Plugin> tonic::server::StreamingService<super::Query> for InitiateQueryProtocolSvc<T> {
						type Response = super::Query;
						type ResponseStream = T::InitiateQueryProtocolStream;
						type Future =
							BoxFuture<tonic::Response<Self::ResponseStream>, tonic::Status>;
						fn call(
							&mut self,
							request: tonic::Request<tonic::Streaming<super::Query>>,
						) -> Self::Future {
							let inner = Arc::clone(&self.0);
							let fut = async move {
								<T as Plugin>::initiate_query_protocol(&inner, request).await
							};
							Box::pin(fut)
						}
					}
					let accept_compression_encodings = self.accept_compression_encodings;
					let send_compression_encodings = self.send_compression_encodings;
					let max_decoding_message_size = self.max_decoding_message_size;
					let max_encoding_message_size = self.max_encoding_message_size;
					let inner = self.inner.clone();
					let fut = async move {
						let method = InitiateQueryProtocolSvc(inner);
						let codec = tonic::codec::ProstCodec::default();
						let mut grpc = tonic::server::Grpc::new(codec)
							.apply_compression_config(
								accept_compression_encodings,
								send_compression_encodings,
							)
							.apply_max_message_size_config(
								max_decoding_message_size,
								max_encoding_message_size,
							);
						let res = grpc.streaming(method, req).await;
						Ok(res)
					};
					Box::pin(fut)
				}
				_ => Box::pin(async move {
					Ok(http::Response::builder()
						.status(200)
						.header("grpc-status", tonic::Code::Unimplemented as i32)
						.header(
							http::header::CONTENT_TYPE,
							tonic::metadata::GRPC_CONTENT_TYPE,
						)
						.body(empty_body())
						.unwrap())
				}),
			}
		}
	}
	impl<T: Plugin> Clone for PluginServer<T> {
		fn clone(&self) -> Self {
			let inner = self.inner.clone();
			Self {
				inner,
				accept_compression_encodings: self.accept_compression_encodings,
				send_compression_encodings: self.send_compression_encodings,
				max_decoding_message_size: self.max_decoding_message_size,
				max_encoding_message_size: self.max_encoding_message_size,
			}
		}
	}
	impl<T: Plugin> tonic::server::NamedService for PluginServer<T> {
		const NAME: &'static str = "hipcheck.Plugin";
	}
}
